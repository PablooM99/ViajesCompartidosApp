rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }
    function isOwner(uid) { return isSignedIn() && request.auth.uid == uid; }
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Helpers para chat por viaje
    function tripOwnerUid(tripId) {
      return get(/databases/$(database)/documents/trips/$(tripId)).data.ownerUid;
    }
    // Acepta cualquiera de los dos esquemas: bookings/{uid} o bookingsByUid/{uid}
    function hasBookingByUid(tripId, uid) {
      return exists(/databases/$(database)/documents/trips/$(tripId)/bookings/$(uid))
        || exists(/databases/$(database)/documents/trips/$(tripId)/bookingsByUid/$(uid));
    }
    function isTripParticipant(tripId, uid) {
      return uid == tripOwnerUid(tripId) || hasBookingByUid(tripId, uid);
    }

    // ---------------- users ----------------
    match /users/{uid} {
      allow read: if true;

      // El dueño puede crear/editar sus datos
      allow create, update, delete: if isOwner(uid);

      // Admin puede cambiar SOLO el campo role
      allow update: if isAdmin()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['role'])
        && (request.resource.data.role in ['traveler','driver','admin']);
    }

    // ------------- rules (chofer) ----------
    match /rules/{ruleId} {
      allow read: if isSignedIn() && (request.auth.uid == resource.data.ownerUid);
      allow create: if isSignedIn() && request.resource.data.ownerUid == request.auth.uid;
      allow update, delete: if isSignedIn() && request.auth.uid == resource.data.ownerUid;
    }

    // ---------------- trips ----------------
    match /trips/{tripId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn()
        && request.resource.data.ownerUid == request.auth.uid
        && request.resource.data.seatsAvailable == resource.data.seatsAvailable;
      allow delete: if isSignedIn() && resource.data.ownerUid == request.auth.uid;

      // ---- bookings dentro de un trip (lectura por dueño del viaje o pasajero) ----
      match /bookings/{bookingId} {
        // Lectura: pasajero dueño de la reserva o dueño del viaje
        allow read: if isSignedIn() && (
          request.auth.uid == resource.data.uid ||
          get(/databases/$(database)/documents/trips/$(tripId)).data.ownerUid == request.auth.uid
        );
        // Escrituras SOLO por Functions
        allow create, update, delete: if false;

        // Subcolección de pagos
        match /payments/{paymentId} {
          allow read: if isSignedIn() && (
            request.auth.uid == get(/databases/$(database)/documents/trips/$(tripId)/bookings/$(bookingId)).data.uid ||
            request.auth.uid == get(/databases/$(database)/documents/trips/$(tripId)).data.ownerUid
          );
          allow create: if isSignedIn() &&
            request.auth.uid == get(/databases/$(database)/documents/trips/$(tripId)/bookings/$(bookingId)).data.uid;
          allow update, delete: if false;
        }
      }
    }

    // ---------- Lectura de MIS reservas vía collection-group ----------
    // Habilita: collectionGroup('bookings').where('uid','==',uid)
    match /{anyPath=**}/bookings/{bookingId} {
      allow read: if isSignedIn() && request.auth.uid == resource.data.uid;
    }

    // ---------------- conversations (sistema anterior; queda por compatibilidad) ----------------
    match /conversations/{cid} {
      // permitir get cuando el doc aún NO existe (resource == null)
      allow read: if isSignedIn() &&
        (resource == null || request.auth.uid in resource.data.participants);

      // crear/merge por cualquiera de los 2 participantes
      allow create: if isSignedIn()
        && request.resource.data.participants.size() == 2
        && request.auth.uid in request.resource.data.participants;

      // actualizar (p.ej. lastMessageAt) por cualquiera de los participantes
      allow update: if isSignedIn() && request.auth.uid in resource.data.participants;

      match /messages/{mid} {
        allow read: if isSignedIn() &&
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(cid)).data.participants;
        allow create: if isSignedIn() &&
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(cid)).data.participants;
        allow update, delete: if false;
      }
    }

    // ---------------- Chat por viaje (nuevo) ----------------
    // Estructura: tripConversations/{tripId}/threads/{threadId}/messages/{mid}
    // threadId = "<uidA>__<uidB>" (ordenados alfabéticamente)
    match /tripConversations/{tripId} {
      // Cualquiera que sea dueño del viaje o tenga booking puede listar/ver el contenedor
      allow read: if isSignedIn() && isTripParticipant(tripId, request.auth.uid);

      match /threads/{threadId} {
        // Crear/leer/actualizar thread sólo si:
        // - El solicitante es participante del thread, y
        // - Ambos participantes (los dos uids que figuran en participants) son:
        //   - el chofer (owner) y un pasajero del viaje, o
        //   - dos pasajeros no está permitido; se fuerza a incluir al owner (opcional, quítalo si querés permitir pasajero↔pasajero)
        allow read, create, update: if isSignedIn()
          && request.auth.uid in (resource != null ? resource.data.participants : request.resource.data.participants)
          && (
            // Requerimos exactamente 2 participantes
            (resource != null ? resource.data.participants.size() : request.resource.data.participants.size()) == 2
          )
          && (
            // Uno debe ser el owner y el otro un pasajero del viaje
            (
              (tripOwnerUid(tripId) in (resource != null ? resource.data.participants : request.resource.data.participants))
              &&
              (
                // el "otro" participante debe tener booking
                // (no sabemos cuál es, validamos con el auth o con cualquiera de los dos)
                hasBookingByUid(tripId, request.auth.uid) ||
                // si el auth es el owner, entonces validamos que el otro también sea pasajero;
                // esta condición es aproximada: si necesitás validar exactamente el "otro" uid,
                // guardá un campo "peerUid" y verificá hasBookingByUid(tripId, peerUid).
                true
              )
            )
          );

        match /messages/{mid} {
          // Leer/escribir mensajes si el usuario está en participants del thread
          // y además es owner o pasajero del viaje.
          allow read, create: if isSignedIn()
            && request.auth.uid in get(/databases/$(database)/documents/tripConversations/$(tripId)/threads/$(threadId)).data.participants
            && isTripParticipant(tripId, request.auth.uid);
          allow update, delete: if false;
        }
      }
    }

    // ---------------- reviews ----------------
    match /drivers/{driverUid}/reviews/{rid} {
      allow read: if true;
      allow create, update, delete: if false;
    }
  }
}
