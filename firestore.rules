rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }
    function isOwner(uid) { return isSignedIn() && request.auth.uid == uid; }
    function isAdmin() {
      return isSignedIn() &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Helpers usados por chat por viaje
    function tripOwnerUid(tripId) {
      return get(/databases/$(database)/documents/trips/$(tripId)).data.ownerUid;
    }
    // (Nota) Si tus bookings tienen ID aleatorio, NO uses esto para validar pasajeros.
    function hasBookingByUid(tripId, uid) {
      return exists(/databases/$(database)/documents/trips/$(tripId)/bookings/$(uid)) ||
             exists(/databases/$(database)/documents/trips/$(tripId)/bookingsByUid/$(uid));
    }
    function isTripParticipant(tripId, uid) {
      return uid == tripOwnerUid(tripId) || hasBookingByUid(tripId, uid);
    }

    // ---------------- users ----------------
    match /users/{uid} {
      allow read: if true;
      allow create, update, delete: if isOwner(uid);

      // Admin solo cambia 'role'
      allow update: if isAdmin()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['role'])
        && (request.resource.data.role in ['traveler','driver','admin']);
    }

    // ------------- rules (chofer) ----------
    match /rules/{ruleId} {
      allow read: if isSignedIn() && (request.auth.uid == resource.data.ownerUid);
      allow create: if isSignedIn() && request.resource.data.ownerUid == request.auth.uid;
      allow update, delete: if isSignedIn() && request.auth.uid == resource.data.ownerUid;
    }

    // ---------------- trips ----------------
    match /trips/{tripId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn()
        && request.resource.data.ownerUid == request.auth.uid
        && request.resource.data.seatsAvailable == resource.data.seatsAvailable;
      allow delete: if isSignedIn() && resource.data.ownerUid == request.auth.uid;

      match /bookings/{bookingId} {
        // lee el pasajero dueño de la reserva o el dueño del viaje
        allow read: if isSignedIn() && (
          request.auth.uid == resource.data.uid ||
          get(/databases/$(database)/documents/trips/$(tripId)).data.ownerUid == request.auth.uid
        );
        // escrituras solo por Cloud Functions
        allow create, update, delete: if false;

        match /payments/{paymentId} {
          allow read: if isSignedIn() && (
            request.auth.uid == get(/databases/$(database)/documents/trips/$(tripId)/bookings/$(bookingId)).data.uid ||
            request.auth.uid == get(/databases/$(database)/documents/trips/$(tripId)).data.ownerUid
          );
          allow create: if isSignedIn() &&
            request.auth.uid == get(/databases/$(database)/documents/trips/$(tripId)/bookings/$(bookingId)).data.uid;
          allow update, delete: if false;
        }
      }
    }

    // ---------- MIS reservas vía collection-group ----------
    match /{anyPath=**}/bookings/{bookingId} {
      allow read: if isSignedIn() && request.auth.uid == resource.data.uid;
    }

    // ---------------- conversations (vigente) ----------------
    match /conversations/{cid} {
      // permitir get aunque el doc aún no exista (UI lo preabre)
      allow read: if isSignedIn() &&
        (resource == null || request.auth.uid in resource.data.participants);

      // crear/merge por cualquiera de los dos participantes
      allow create: if isSignedIn()
        && request.resource.data.participants.size() == 2
        && request.auth.uid in request.resource.data.participants;

      // actualizaciones de meta (lastMessage, lastMessageAt)
      allow update: if isSignedIn() && request.auth.uid in resource.data.participants;

      match /messages/{mid} {
        // permitir mientras el padre no existe (ventana de creación) o si soy participante
        allow read: if isSignedIn() && (
          !exists(/databases/$(database)/documents/conversations/$(cid)) ||
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(cid)).data.participants
        );
        allow create: if isSignedIn() && (
          !exists(/databases/$(database)/documents/conversations/$(cid)) ||
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(cid)).data.participants
        );
        allow update, delete: if false;
      }
    }

    // ---------------- Chat por viaje ----------------
// Estructura: tripConversations/{tripId}/threads/{threadId}/messages/{mid}
// threadId = "<uidA>__<uidB>" (ordenados alfabéticamente)
match /tripConversations/{tripId} {
  // Leer el contenedor no expone datos sensibles; lo dejamos entrar firmado.
  allow read: if isSignedIn();

  match /threads/{threadId} {
    function reqParts() {
      return (resource != null ? resource.data.participants : request.resource.data.participants);
    }

    // Crear/leer/actualizar un thread solo si:
    // - Hay exactamente 2 participantes
    // - El autenticado está en participants
    // - Y SIEMPRE está incluido el owner del trip (chat pasajero↔chofer)
    allow read, create, update: if isSignedIn()
      && reqParts().size() == 2
      && (request.auth.uid in reqParts())
      && (tripOwnerUid(tripId) in reqParts());

    match /messages/{mid} {
      // Leer/escribir mensajes si el autenticado está en participants
      // y el owner del viaje también está en participants (evita pasajero↔pasajero)
      allow read, create: if isSignedIn()
        && (request.auth.uid in get(/databases/$(database)/documents/tripConversations/$(tripId)/threads/$(threadId)).data.participants)
        && (tripOwnerUid(tripId) in get(/databases/$(database)/documents/tripConversations/$(tripId)/threads/$(threadId)).data.participants);

      allow update, delete: if false;
    }
  }
}
  }}